@; 0x2000 0000 + 0x0000 8000 (32Кб)

@; GNU AS – просто комментарий в котором указываем компилятор (для себя)

@; Настройки для компилятора:
.syntax unified
.thumb            @ тип используемых инструкций Thumb
.cpu cortex-m3    @ семейство микроконтроллера 

.include "../libs/mdr32f9q2i.inc"   @ файл определений микроконтроллера

@; макрос псевдокоманды MOV32, пока просто используем, не вникая как, что и почему
.macro	MOV32 regnum,number
	MOVW \regnum,:lower16:\number
	MOVT \regnum,:upper16:\number
.endm

.equ PB1 ,1
.equ PB2 ,2
.equ PC2 ,2
.equ LED1_PIN ,PB1
.equ LED2_PIN ,PB2
.equ LED3_PIN ,PC2
.equ LED_HL1 ,(1 << PB1) @; red
.equ LED_HL2 ,(1 << PB2) @; green
.equ LED_HL3 ,(1 << PC2) @; blue

@; Наша программа:
.section .text

@; Таблица указателей перехода которая должная быть размещена с адреса 0x08000000
.word	0x20008000	@; Стек
.word	Reset+1	@; Адрес перехода при сбросе. 
			@; Внимание! Для корректности работы необходимо к адресу
			@; прибавить "1" - это показывает процессору что команда
			@; по адресу перехода будет в формате Thumb (а не ARM),
			@; если этого не сделать, то микроконтроллер 
			@; будет уходить в ошибку (в прерывание Hard Fault)

@; Наша программа (должна быть размещена после таблицы указателей переходов)
Reset:			
	@; включим тактирование порта B и C
	MOV32	R0, MDR_RST_CLK_PER_CLOCK 
	MOV32   R1, PER_CLOCK_PCLK_EN_PORTB | PER_CLOCK_PCLK_EN_PORTC
	LDR	    R2, [R0]			    @; прочитали значение регистра
	ORR	    R1, R1, R2              @; логическое, побитовое ИЛИ : R1= R1 ИЛИ R2
	STR	    R1, [R0]                @; запись R1 по адресу указанному в R0

	@; MDR_PORTB->ANALOG |= LED_HL1 | LED_HL2;
	MOV32	R0, MDR_PORTB_ANALOG	@; адрес
	MOV32   R1, LED_HL1 | LED_HL2	@; значение
	LDR   	R2, [R0]				@; прочитали значение регистра
	ORR	   	R1, R1, R2             	@; логическое, побитовое ИЛИ: R1= R1 ИЛИ R2
	STR		R1, [R0]               	@; запись R1 по адресу указанному в R0

	@; MDR_PORTB->OE |= LED_HL1 | LED_HL2; 
	MOV32	R0, MDR_PORTB_OE		@; адрес
	MOV32   R1, LED_HL1 | LED_HL2	@; значение
	LDR   	R2, [R0]				@; прочитали значение регистра
	ORR	   	R1, R1, R2             	@; логическое, побитовое ИЛИ: R1= R1 ИЛИ R2
	STR		R1, [R0]               	@; запись R1 по адресу указанному в R0

	@; MDR_PORTB->PWR |= (0b01 << (PB1*2)) | (0b01 << (PB2*2)); // 01 - lower
	MOV32	R0, MDR_PORTB_PWR		@; адрес
	MOV32   R1, (1 << (LED1_PIN*2)) | (1 << (LED2_PIN*2))	@; значение
	LDR   	R2, [R0]				@; прочитали значение регистра
	ORR	   	R1, R1, R2             	@; логическое, побитовое ИЛИ: R1= R1 ИЛИ R2
	STR		R1, [R0]               	@; запись R1 по адресу указанному в R0


	@; MDR_PORTC->ANALOG |= LED_HL3;
	MOV32	R0, MDR_PORTC_ANALOG	@; адрес
	MOV32   R1, LED_HL3				@; значение
	LDR   	R2, [R0]				@; прочитали значение регистра
	ORR	   	R1, R1, R2             	@; логическое, побитовое ИЛИ: R1= R1 ИЛИ R2
	STR		R1, [R0]               	@; запись R1 по адресу указанному в R0

	@; MDR_PORTC->OE |= LED_HL3; 
	MOV32	R0, MDR_PORTC_OE		@; адрес
	MOV32   R1, LED_HL3				@; значение
	LDR   	R2, [R0]				@; прочитали значение регистра
	ORR	   	R1, R1, R2             	@; логическое, побитовое ИЛИ: R1= R1 ИЛИ R2
	STR		R1, [R0]               	@; запись R1 по адресу указанному в R0

	@; MDR_PORTC->PWR |= (0x1<<(PC2*2)); // 01 - lower
	MOV32	R0, MDR_PORTC_PWR		@; адрес
	MOV32   R1, (1 << (LED3_PIN*2))	@; значение
	LDR   	R2, [R0]				@; прочитали значение регистра
	ORR	   	R1, R1, R2             	@; логическое, побитовое ИЛИ: R1= R1 ИЛИ R2
	STR		R1, [R0]               	@; запись R1 по адресу указанному в R0
		
	@; MDR_PORTB->RXTX |= LED_HL1;
	MOV32	R0, MDR_PORTB_RXTX		@; адрес
	MOV32   R1, LED_HL1				@; значение
	LDR   	R2, [R0]				@; прочитали значение регистра
	ORR	   	R1, R1, R2             	@; логическое, побитовое ИЛИ: R1= R1 ИЛИ R2
	STR		R1, [R0]               	@; запись R1 по адресу указанному в R0

	@; MDR_PORTB->RXTX |= LED_HL2;	
	MOV32	R0, MDR_PORTB_RXTX		@; адрес
	MOV32   R1, LED_HL2				@; значение
	LDR   	R2, [R0]				@; прочитали значение регистра
	ORR	   	R1, R1, R2             	@; логическое, побитовое ИЛИ: R1= R1 ИЛИ R2
	STR		R1, [R0]               	@; запись R1 по адресу указанному в R0

	@; MDR_PORTC->RXTX |= LED_HL3;
	MOV32	R0, MDR_PORTC_RXTX		@; адрес
	MOV32   R1, LED_HL3				@; значение
	LDR   	R2, [R0]				@; прочитали значение регистра
	ORR	   	R1, R1, R2             	@; логическое, побитовое ИЛИ: R1= R1 ИЛИ R2
	STR		R1, [R0]               	@; запись R1 по адресу указанному в R0


BLINK_LOOP:
	@; включим светодиод LED_HL1
	MOV32	R0, MDR_PORTB_RXTX  	@; адрес
	MOV32   R1, LED_HL1   			@; значение
	LDR   	R2, [R0]				@; прочитали значение регистра
	ORR	   	R1, R1, R2             	@; логическое, побитовое ИЛИ: R1= R1 ИЛИ R2
	STR		R1, [R0]               	@; запись R1 по адресу указанному в R0
		
	@; выключим светодиод LED_HL2
	MOV32	R0, MDR_PORTB_RXTX  	@; адрес
	MOV32   R1, ~LED_HL2   			@; значение
	LDR   	R2, [R0]				@; прочитали значение регистра
	AND   	R1, R1, R2             	@; логическое, побитовое И: R1= R1 И R2
	STR		R1, [R0]               	@; запись R1 по адресу указанному в R0
	
	@; включим светодиод LED_HL3
	MOV32	R0, MDR_PORTC_RXTX  	@; адрес
	MOV32   R1, LED_HL3   			@; значение
	LDR   	R2, [R0]				@; прочитали значение регистра
	ORR	   	R1, R1, R2             	@; логическое, побитовое ИЛИ: R1= R1 ИЛИ R2
	STR		R1, [R0]               	@; запись R1 по адресу указанному в R0

	BL		DELAY   @;  пауза
	
	@; выключим светодиод LED_HL1
	MOV32	R0, MDR_PORTB_RXTX  	@; адрес
	MOV32   R1, ~LED_HL1   			@; значение
	LDR   	R2, [R0]				@; прочитали значение регистра
	AND   	R1, R1, R2             	@; логическое, побитовое И: R1= R1 И R2
	STR		R1, [R0]               	@; запись R1 по адресу указанному в R0

	@; включим светодиод LED_HL2
	MOV32	R0, MDR_PORTB_RXTX  	@; адрес
	MOV32   R1, LED_HL2   			@; значение
	LDR   	R2, [R0]				@; прочитали значение регистра
	ORR	   	R1, R1, R2             	@; логическое, побитовое ИЛИ: R1= R1 ИЛИ R2
	STR		R1, [R0]               	@; запись R1 по адресу указанному в R0
	
	@; выключим светодиод LED_HL3
	MOV32	R0, MDR_PORTC_RXTX  	@; адрес
	MOV32   R1, ~LED_HL3   			@; значение
	LDR   	R2, [R0]				@; прочитали значение регистра
	AND   	R1, R1, R2             	@; логическое, побитовое И: R1= R1 И R2
	STR		R1, [R0]               	@; запись R1 по адресу указанному в R0

	BL		DELAY   @;  пауза	

	B		BLINK_LOOP @; делаем цикл


DELAY:
	MOV32	R2, 0x00100000 	@; повтор цикла задержки 0x0010 0000 раз.
Delay_loop:	
	SUBS	R2, R2, 1
	BNE		Delay_loop
	
	BX	LR


